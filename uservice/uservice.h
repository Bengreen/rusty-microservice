#ifndef uservice_h
#define uservice_h

/* Generated with cbindgen:0.20.0 */

/* Warning, this file is autogenerated by cbindgen. Don't modify this manually. */

#include <stdarg.h>
#include <stdbool.h>
#include <stdint.h>
#include <stdlib.h>

/**
 * Representation of the APIs required to load a SO for UService
 *
 * Initial attempt at building this class used the libloading symbols. But after bringing through and attempting to use with warp web server I ran into an issue.
 * The warp web server assumes a `static lifetime for the web server. This contrasts with the libloading symbol with has a definitive lifetime. Therefore an object witth
 * a libloading based lifetime cannot be used by a warp object as their lifetimes are contradictory.
 *
 * As an alternative we can 'eject' the lifetimes out of the symbols and take ownership of the lifetimes ourselves. This should result in a lifetime for the SoService that is not
 * contradictory with the Warp library
 */
typedef struct SoService SoService;

/**
 * A UService allowsing multiple pServices to be assembled within it.
 * The UService provides the basic scaffolding for the web service and a loader capabilty to load and service picoservices.
 * The basic UService will reply with status information on the picoservcies provided
 */
typedef struct UService UService;

/**
 * Register a shared library for by the name of the library
 *
 * # Safety
 *
 * It is the caller's guarantee to ensure `msg`:
 *
 * - is not a null pointer
 * - points to valid, initialized data
 * - points to memory ending in a null byte
 * - won't be mutated for the duration of this function call
 */
Library *so_library_register(const char *name);

/**
 * Free the library
 */
void so_library_free(Library *ptr);

/**
 * Initialise the FFI based logging for this crate
 */
void uservice_logger_init(LogParam param);

/**
 * Initialise the UService  *
 */
struct UService *uservice_init(const char *name);

/**
 * Free the UService  *
 */
int32_t uservice_free(struct UService *ptr);

/**
 * Start the microservice and keep exe control until it is complete  *  * If the function throws a panic while running the error is returned via the local thread memory and a non-zero value is returned.  *  * retain exec until the service exits  *  * ```  * uservice:uservice_start()  * ```
 */
int32_t uservice_start(struct UService *uservice_ptr);

uint32_t uservice_stop(struct UService *ptr);

/**
 * Initialise the FFI based logging for this crate
 */
uint32_t pservices_logger_init(struct UService *ptr, LogParam param);

/**
 * Initialise the FFI based logging for this crate
 */
int32_t pservices_init(struct UService *uservice, const char *config_yaml);

/**
 * Initialise the FFI based logging for this crate
 */
int32_t pservice_register(struct UService *uservice, const char *name, const char *library);

/**
 * Initialise the FFI based logging for this crate
 */
uint32_t pservice_free(struct UService *ptr, const char *name);

/**
 * Register the so functions for the library
 */
struct SoService *so_service_register(Library *ptr);

/**
 * Free the service for the so library
 */
void so_service_free(struct SoService *ptr);

/**
 *Call the process function
 */
void so_service_logger_init(struct SoService *ptr, LogParam param);

/**
 * Call the init function
 */
int32_t so_service_init(struct SoService *ptr, int32_t param);

/**
 *  * Call the process function
 */
int32_t so_service_process(struct SoService *ptr, int32_t param);

/**
 * Add SO to uservice
 */
void uservice_add_so(struct UService *uservice_ptr,
                     const char *name,
                     struct SoService *soservice_ptr);

struct SoService *uservice_remove_so(struct UService *uservice_ptr, const char *name);

/**
 * Create a health probe
 *
 * Create a health probe that can be used to track health of a part of the service and used within a healthcheck to create a readiness or liveness check.
 *
 * ```
 * use std::ffi::{CString};
 * let health_name = CString::new("USERVICE_LOG_LEVEL").expect("CString::new failed");
 *
 * let hc = uservice::createHealthProbe(health_name.as_ptr(), 2);
 * assert_eq!(hc, 20);
 * ```
 */
int createHealthProbe(const char *name,
                      int margin_ms);

uint32_t panic_check(void);

#endif /* uservice_h */
